# **Basic Analysis(基本语义分析)**

&emsp;**Basic Analysis**是`hscope`分析流程的第一阶段(Phase I)。该阶段主要在GIR的基础上进行一系列基础的语义分析，旨在识别程序的静态结构、依赖关系、控制流以及初步的数据流信息。<br>
&emsp;整个流程由`BasicAnalysis.run()`驱动，按顺序执行以下关键子模块的分析。

##             1.**ScopeHierarchy(作用域层级分析)**

&emsp;**目标**：<br>
&emsp;识别代码中的每个符号所属的作用域（如属于一个块内部的、文件全局的、或是一个类内部的），并将这些作用域的层级关系梳理清晰（例如明确哪些作用域隶属于哪个文件），最终建立一个完整的符号声明表。

&emsp;**核心流程**：<br>
&emsp;1.初始化和遍历：遍历整个编译单元(Unit)的GIR语句，准备分析数据。<br>
&emsp;2.作用域构建：遍历并分析GIR中的各类声明语句。这一步包含了作用域的发现（创建Scope对象）和**修正**（如将类成员正确归属到类作用域，将函数参数作用域修正为函数内部）。在构建过程中，为了确保能够准确地确定每个语句所属的作用域，系统会调用`determineScope`函数进行递归查找父节点，从而建立正确的作用域层级关系，最终完成整个作用域树的构建。<br>
&emsp;3.符号汇总：汇总分析完成的符号声明信息，建立符号名到声明语句的映射。

&emsp;**关键输出**：<br>
&emsp;**ScopeSpace**：核心数据结构，存储了分析过程中创建的所有`Scope`对象。它主要用于维护所有作用域节点的集合及其层级关系(Parent-Child)，支持通过stmt_id快速查找作用域的详细信息（如类型、名称、属性等）。<br>
&emsp;**UnitSymbolDeclSummary**：单元内的符号声明汇总。它包含了符号名到作用域ID的映射表，以及每个作用域内定义了哪些符号。同时，它还记录了作用域的可见性关系（即一个作用域内部可以访问哪些其他外部作用域），这对后续的变量名解析(Resolve)至关重要。

##             2.**EntryPointGenerator(入口点寻找)**

&emsp;**目标**：<br>
&emsp;根据预设规则识别程序的入口点(Entry Points)，例如`main`函数、测试函数。

&emsp;**核心流程**：<br>
&emsp;1.加载规则：读取配置文件（如`entry_points.yaml`），获取基于方法名（如start, main）、属性（如@public）或文件路径的入口点判定规则。<br>
&emsp;2.匹配与收集：扫描所有方法声明，将符合任意一条规则的方法标记为入口点。

&emsp;**关键输出**：<br>
&emsp;**entryPointResults**：一个集合(`Set<Integer>`)，存储了所有被识别为程序入口的方法的stmt_id。后续的分析（如调用图构建）通常从这些入口点开始。

##             3.**ImportHierarchy(导入层级分析)**

&emsp;**目标**：<br>
&emsp;分析模块间的导入(Import)和导出(Export)关系，构建一个精细的依赖图（不仅包含文件与文件之间的依赖，并精确到符号级别），梳理清晰文件中使用的特定符号（如类、函数）究竟引用自哪个外部文件的哪个导出项，最终解决跨文件的符号解析问题。

&emsp;**核心流程**：<br>
&emsp;1.初始化：将所有模块(Unit)作为初始节点加入导入图。<br>
&emsp;2.导出分析：识别每个模块的公共符号(Public Symbols)，即对外可见、可被其他模块引用的类、函数等。<br>
&emsp;3.导入构建：这一步骤主要是负责连边，将单一的符号通过依赖关系连接起来。系统首先解析`import`语句中的字符串路径，搜索匹配的模块文件。定位到目标模块后，进一步匹配具体的导出符号，对于`import *`(Namespace Import)等情况，系统会自动递归分析目标模块，将其所有导出符号展开，确保依赖关系能精确覆盖到每一个具体的子符号。最后在导入图中创建有向边，连接“引用点”（当前Import语句）与“定义点”（目标模块或符号），对于无法解析的路径，则会创建标记为`UNSOLVED_SYMBOL`的虚拟节点以保证图结构的完整性。

&emsp;**关键输出**：<br>
&emsp;**ImportGraph**：一个包含符号节点(Unit或Symbol)和导入边的图结构。它精确描述了“哪个模块的哪条语句导入了哪个模块的哪个符号”，是跨文件引用解析的基础。<br>
&emsp;**ImportDeps**：粗粒度的依赖图，仅描述Unit到Unit之间的依赖关系，用于快速查询文件间的引用情况。

##             4.**TypeHierarchy(类型层级分析)**

&emsp;**目标**：<br>
&emsp;分析面向对象语言中的类继承关系，构建一个清晰的类型图（不仅包含类与类之间的继承连线，还包含方法的归属信息），梳理清晰类中可用的特定符号（如方法、字段）究竟是定义在当前类还是继承自父类，解决类成员的查找与继承解析问题。

&emsp;**核心流程**：<br>
&emsp;1.构建类型图：这一过程构建了完整的类继承网。遍历所有类声明语句，解析其中的继承信息。将父类名称映射为具体的类符号ID后，在图结构中建立子类到父类的有向边。<br>
&emsp;2.方法归属与继承：基于类型图，系统计算每个类实际拥有的完整方法集合。它首先收集类自身定义的方法，随后沿继承关系向上回溯，将父类中未被子类重写的方法“拉取”合并到当前类中。这一扁平化处理生成了`MethodsInClass`表，使得后续分析在查询类成员时，能直接获取包括继承方法在内的所有可用方法，无需重复遍历继承树。

&emsp;**关键输出**：<br>
&emsp;**TypeGraph**：类的继承关系图(Class Hierarchy Graph)。节点为Class ID，边表示“继承来自xx”。<br>
&emsp;**MethodsInClass**：类与其成员方法的映射表。不仅包含该类自己定义的方法，还包含了它从父类继承的所有可用方法。

##             5.**ControlFlowAnalysis(控制流分析)**

&emsp;**目标**：<br>
&emsp;为每个方法构建控制流图(CFG)，描述程序执行的路径和跳转逻辑。

&emsp;**核心流程**：<br>
&emsp;1.块级分析：以基本块(Block)为单位，递归遍历方法体内的所有语句。在此过程中，分析器会实时维护一个**前驱语句集合**，用于记录所有可能流向当前位置的上一条语句（例如在`if-else`分支结束后，两个分支的末尾语句都会被加入该集合），从而确保每条新语句都能正确连接到其上游节点。<br>
&emsp;2.结构化控制流构建：识别`if`、`while`、`for`、`try-catch`等结构化语句。根据不同的语意，在图中添加相应的控制流边（如`IF_TRUE`、`IF_FALSE`、`LOOP_BACK`、`EXCEPTION`），正确连接条件判断点、循环体和异常处理块。<br>
&emsp;3.非结构化跳转处理：处理`break`、`continue`、`return`、`throw`等跳转指令。这些指令会中断正常的顺序执行流，分析器会将它们暂时收集起来，并在进入下一阶段（如退出循环或方法结束）时，将其连接到正确的逻辑目标节点，从而闭合整个控制流图。

&emsp;**关键输出**：<br>
&emsp;**MethodCfg**：方法的控制流图数据。它是一个映射(`Map<Integer, Set<Edge>>`)，键为语句ID，值为该语句的所有后继边。它是进行函数内数据流分析（如Def-Use）的基础。

##             6.**StmtDefUseAnalysis(定义-使用分析)**

&emsp;**目标**：<br>
&emsp;基于控制流图执行变量的Def-Use分析，识别程序中每一处变量的定义点与使用点，并利用作用域信息将它们精确关联。

&emsp;**核心流程**：<br>
&emsp;1.遍历与识别：系统沿着控制流路径遍历方法内的每一条语句。针对每种语句类型（如赋值、调用、声明），分析其语义，初步识别并记录当前语句的定义集合和使用集合。<br>
&emsp;2.链构建与状态同步：利用ScopeHierarchy阶段建立的符号表，将识别出的变量名解析为具体的符号ID。在此过程中，会用到一个**`addStatusWithSymbolIdSync`**函数，它负责同步更新每条语句的分析状态(`StmtStatus`)，将符号ID与定义与使用集合串起来，还负责处理复杂的符号查找逻辑（包括局部变量、闭包捕获、全局变量等），最终将定义点与使用点在逻辑上连接起来。

&emsp;**关键输出**：<br>
&emsp;**StmtStatus**：每条语句的分析状态记录。详细包含了该语句定义了哪些符号(Defined Symbols)、使用了哪些符号(Used Symbols)以及其他流敏感信息。<br>
&emsp;**MethodDefUseSummary**：方法级的汇总信息。概括了该方法内部所有的定义和使用情况，为后续的跨函数数据流分析提供摘要数据。<br>
&emsp;**s2space(SymbolStateSpace)**：符号与状态空间。存储了分析过程中生成的所有临时符号对象(Symbol)和状态对象(State)，是`StmtStatus`中符号索引的实际载体。
