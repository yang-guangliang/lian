# 基于函数摘要分析

&emsp;传统的静态分析工作无法满足软件安全分析的精度需求。为了实现高精度的语义分析，我们基于抽象解释将程序运行分为两个层次：1）Symbol符号层，即变量等标识符；2）运行时状态层State，将Symbol在真实运行时可能的内容抽象建模成一个所谓的"状态(State)"，并且将Symbol与对应的States进行关联。语义分析时，我们模拟程序动态运行的过程，跟踪和计算States的变化，从而实现对状态的高精度分析。<br>
&emsp;自底向上分析大致可分为三个框架：
    
&emsp;1.GIR指令分析<br>
&emsp;GIR指令分析中，我们按控制流顺序逐条取当前方法中的GIR指令进行状态(State)级别的语义分析。对于一条GIR指令，其operation字段反映了其所属的操作类型，依据该字段，GIR指令会被分发到相应类型的处理函数中。比如，若operation为"assign_stmt"，则会分发到assign_stmt_state函数。在处理函数中，我们根据不同类型的指令，进行States的计算和传播。

&emsp;2.过程内分析<br>
&emsp;在过程内分析中，我们对一个函数的每条语句进行GIR指令分析。为了避免分析大型程序时的状态爆炸问题，并且减少对同一函数的重复分析，我们以单个函数为一个分析单元。每分析完一个函数，便为其生成一个状态级别的函数摘要。函数摘要一经生成不会改变。
函数摘要保存了该函数关键变量的最终状态，是一个{Symbol->States}的映射。关键变量包括：函数参数、外部变量、this变量和return变量。函数摘要记录关键变量从起始状态开始，经过该函数状态计算后的最终变化(比如，对参数添加了field)。

&emsp;3.过程间分析<br>
&emsp;过程间分析建立在过程内分析的基础上。当遇到一条形如caller call callee的call_stmt时。我们首先判断该callee是否已被分析过。若已被分析，我们只需将callee函数的函数摘要应用至caller的对应状态上，即可完整地保留此次调用生成的状态语义；若尚未被分析，我们立即中断对当前函数的分析，转而先去分析callee函数。当caller依赖的所有callee都被分析完，生成函数摘要后，我们会恢复刚才被中断的caller的分析。通过这种方式，既能避免状态爆炸，又能减少重复的分析。<br>
&emsp;应用函数摘要时， 我们先从Symbol层面将caller和callee关联上(比如形参和实参的关联、外部变量的关联)。随后，基于每对关联的Symbol，分别取出对应的caller中的States和callee函数摘要中的States'，将States'的状态应用到States，最大程度确保将callee中的States语义映射到caller中。

&emsp;需要注意的是，在自底向上的分析过程中，单个函数即为分析边界，不关注传入函数的外部变量和函数参数的具体状态。在本阶段中，我们会将这些来自外部的状态抽象为"anything"，意为可能取到任何值。若分析过程中我们发现这些anything状态流到了敏感操作，如call anything()等，我们会重点标记，记录在函数摘要中。在随后的全局分析中，我们会从全局视角解析出这些关键anything的具体状态。
