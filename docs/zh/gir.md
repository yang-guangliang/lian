本页面描述了我们自主研发的通用性中间语言。与以往语言相比，GIR更侧重于用简明的方式表达变量符号之间的逻辑关系，类型推断、控制流等等语义则交给后续“多合一”语义分析引擎处理。

| **GIR**                       | **属性**                                                     | **描述**                                                     |
| ----------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| program                       | name<br>body                                                 |                                                              |
| namespace_decl                | name<br>body                                                 | namespace name {body}                                        |
| comment_stmt                  | data                                                         |                                                              |
| package_stmt                  | name                                                         | 表示package声明语句，格式为package name                      |
| import_stmt                   | attrs<br>module_path<br>alias                                | 表示import语句，格式为import module_path或者import module_path as alias <br><br/>注意：module_path是目录路径或是文件路径 |
| from_import_stmt              | attrs<br>module_path<br>name<br>alias                        | attrs说明： <br/>- unit : 表示name必须是文件名字，而不是文件夹名字<br/>- init：import时，必须对目标文件进行初始化 |
| export_stmt                   | attrs<br>name<br>alias                                       | 表示导出命令，格式为export <name> as <alias> <br/>attrs用于标识是否是export default(仅用于js) |
| from_export_stmt              | attrs<br>module_path<br>name<br>alias                        |                                                              |
| require_stmt                  | target<br>name                                               | 表示require语句，格式为target = require(name)<br/>只在php中出现 |
| class_decl                    | attrs<br>name<br>supers<br>static_init<br>init<br>fields<br>methods<br>nested | 表示类声明其中attrs表示属性内容，例如public\static\private等等<br/>name表示类的名字<br/>supers表示父类名字，是个列表<br/>type_parameters是所有的类型参数，是个列表<br/>fields是所有的成员变量声明，每一个成员变量用variable_decl表示，详见variable_decl的说明<br/>methods是所有的成员函数，是个列表；每一个成员函数用method_decl表示<br/>nested是个列表，表示了嵌套的其他声明<br/>init和static_init是用于存放初始化内容，init用于存放一般field的初始化，static_init用于存放静态field初始化内容 <br/><br/>例如public class name extends a implements b {           <br/>&emsp;&emsp;&emsp;int i = 1;<br/>} <br/><br/>可以写成<br/>{""class_decl"": {""attrs"": [""public""], ""name"": name, ""supers"": [""a"", ""b""], ""fields"": [{""variable_decl"": {""data_type"": int, ""name"":i}}], ""init"": [ this.i = 1] }} |
| record_decl                   | attrs<br>name<br>supers<br>type_parameters<br>static_init<br>init<br>fields<br>methods<br>nested | 同上                                                         |
| interface_decl                | attrs<br>name<br>supers<br>type_parameters<br>static_init<br>init<br>fields<br>methods<br>nested | 同上                                                         |
| enum_decl                     | attrs<br>name<br>supers<br>static_init<br>init<br>fields<br>methods<br>nested | 同上                                                         |
| annotation_type_decl          | attrs<br>name<br>static_init<br>init<br>fields<br>methods<br>nested | 同上                                                         |
| annotation_type_elements_decl | attrs<br>data_type<br>name<br>value                          | 同上                                                         |
| struct_decl                   | attrs<br>name<br>fields                                      | 同上                                                         |
| parameter_decl                | attrs<br>data_type<br>name<br>default_value                  | 用于存放参数声明<br/>attrs代表了属性<br/>data_type代表了该参数的数据类型<br/>name代表了参数名字<br/>default_value代表默认值 <br/><br/>例如int f(int a, int b = 4); f函数声明中的参数列表为[{""parameter_decl"": { ""data_type"": ""int"", ""name"": ""a""}},{....}] |
| variable_decl                 | attrs<br>data_type<br>name                                   | 用于存放本地变量声明或者class内部field声明<br/>attrs为属性<br/>data_type代表了该变量的数据类型<br/>name代表了变量的名字 <br/><br/>例如signed int i  = 10;可以写成两条指令，一条为变量声明，一条为赋值语句<br/>[{""variable_decl"": {""attrs"": ""signed"", ""data_type"": ""int"", ""name"": ""i""}},{""assign_stmt"": {""target"": ""i"", ""operand"": 10}}] |
| method_decl                   | attrs<br>data_type<br>name<br>parameters<br>body             | 该指令用于表示函数声明attrs为该函数的属性，例如public\static等<br/>data_type为返回值的数据类型<br/>name为函数名称<br/>parameters是参数列表，为列表<br/>init是参数指明了参数初始化内容，为列表<br/>body为函数内部具体指令，为列表 <br/><br/>以java为例，public int f(int a ) {}<br/>attrs: public<br/>data_type: int<br/>name: f<br/>parameters对应的是个list，里面每一项都是parameter_decl: []  <br/><br/>另外，需要注意的是，如果碰到匿名函数，也需要转为有名函数 <br/><br/>譬如python里面lamda x: x+1<br/>转为def tmp_method(x):              return x + 1 |
| assign_stmt                   | data_type<br>target<br>operand<br>operator<br>operand2       | 赋值语句 <br/>target = operand [<operator> operand2] <br/>如果operand2缺失的话，是一元操作，例如a=b，或者a = -b |
| call_stmt                     | target<br>name<br>positional_args<br>packed_positional_args<br>named_args<br>packed_named_args<br>data_type<br>prototype | 用于调用函数，格式为target = name(args)<br/>target是函数返回值，一般为临时变量<br/>name为被调用函数的名字<br/>positional_args是位置参数列表<br/>data_type为返回值的数据类型<br/>prototype为被调用函数的原型，llvm和dalvik等中间语言会用到<br/>例如e = o.f(a, b, c + d)<br/>首先改写<br/>%v1 = o.f<br/>%v2 = c + d<br/>%v3 = %v1(a, b, %v2) // positional_args:[a, b, %v2]<br/>e = %v3 <br/>======================<br/>关于参数的说明：<br/>positional_args是位置参数列表<br/>packed_positional_args是解包位置参数：如果当参数列表中的参数用到解包符号时，将所有的位置参数保存为一个变量，存放到packed_positional_args中；positional_args和packed_positional_args是互斥关系，只能用一个<br/>named_args是关键字参数列表<br/>packed_named_args是打包关键字参数：当参数列表中的参数用到字典解包符号时，将所有的关键字参数保存为一个变量，存放到packed_named_args中；named_args和packed_named_args也是互斥关系 <br/><br/>例如<br/>f(a,b,c, d=3)<br/>只需要提供positional_args和named_args即可<br/>call_stmt, name:f, positional_args:[a,b,c], named_args:{d:3} <br/><br/>再例如，f(a, b, c, *l, d, a = b, c = d)<br/>这里面就用到解包操作，所以会提供packed_positional_args和named_args<br/>变成如下中间语言：<br/>%v0 = [a, b, c]<br/>%v1 = %v0.update(l)<br/>%v2 = %v1.append(d)<br/>call_stmt, name:f, packed_positional_args:%v2, named_args:{a:b, c:d} |
| echo_stmt                     | name                                                         | php中的echo指令                                              |
| exit_stmt                     | name                                                         | php中的exit指令                                              |
| return_stmt                   | name                                                         | 用于返回变量，格式为return name                              |
| if_stmt                       | condition<br>then_body<br>else_body                          | 用于表示if.else其中condition是个变量，then_body和else_body分别为对应的指令列表 <br/><br/>例如if (a + b > c) {}<br/>%v1 = a + b<br/>%v2 = %v1 > c<br/>if (%v2) ... |
| dowhile_stmt                  | condition<br>body                                            | 类似于if                                                     |
| while_stmt                    | condition<br>body<br>else_body                               | 类似于if                                                     |
| for_stmt                      | init_body<br>condition<br>condition_prebody<br>update_body<br>body | 传统for循环，格式为<br/>for (init_body; condition_prebody; condition; update_body) {}<br/>init_body为初始化块，为指令列表<br/>condition_prebody存在用于判断condition的前置指令，为指令列表<br/>condition为变量<br/>update_body为每次循环迭代需要执行的指令列表<br/><br/> 例如<br/>for (int a = 1, b = 3; a +  b < 10; a ++, b++) {}<br/>其中间语言逻辑结构为<br/>for_stmt: [  <br/>&emsp;&emsp;init_body: [       <br/>&emsp;&emsp;&emsp;&emsp;variable_decl int a       <br/>&emsp;&emsp;&emsp;&emsp;a = 1       <br/>&emsp;&emsp;&emsp;&emsp;variable_decl int b       <br/>&emsp;&emsp;&emsp;&emsp;b = 3   <br/>&emsp;&emsp;]  <br/>&emsp;&emsp;condition_prebody: [          <br/>&emsp;&emsp;&emsp;&emsp;%v1 = a + b          <br/>&emsp;&emsp;&emsp;&emsp;%v2 = %v1 < 10  <br/>&emsp;&emsp;]  <br/>&emsp;&emsp;condition: %v2  <br/>&emsp;&emsp;update_body: [        <br/>&emsp;&emsp;&emsp;&emsp;a = a + 1        <br/>&emsp;&emsp;&emsp;&emsp;b = b + 1  <br/>&emsp;&emsp;]  <br/>&emsp;&emsp;body : []<br/>] |
| forin_stmt                    | attrs<br>data_type<br>name<br>receiver<br>body               | 类似于传统for<br>attrs表示迭代变量属性<br/>data_type为迭代变量数据类型<br/>name为迭代变量<br/>receiver为目标变量<br/>body为指令列表<br/>格式为 for attrs data_type name in receiver {} <br/><br/>例如  for x in list<br/>可以写成<br/>forin receiver:list name:x <br/><br/>例如for a, b in list:    <br/>&emsp;&emsp;&emsp;&emsp;body<br/>可以写成<br/>forin receiver:list name:%v0:     <br/>&emsp;&emsp;array_read a = %v0[0]    <br/>&emsp;&emsp;array_read b = %v0[1]     <br/>&emsp;body |
| for_value_stmt                | attrs<br>data_type<br>name<br>receiver<br>body               | 类似于for in， 为了 js 中的 for of 和 php 中的 for each 设计 |
| switch_stmt                   | condition<br>body                                            | 表示switch指令，格式为switch(condition) <body><br/>其中condition为用于判断的变量 |
| case_stmt                     | condition<br>body                                            | 表示case指令，格式为switch(condition) <body><br/>其中condition为用于判断的变量 |
| default_stmt                  | body                                                         | 表示default指令，格式为default <body>                        |
| break_stmt                    | name                                                         | 表示break指令，格式为break name                              |
| continue_stmt                 | name                                                         | 表示continue指令，格式为continue name                        |
| goto_stmt                     | name                                                         | 表示goto指令，格式为goto name                                |
| yield_stmt                    | name                                                         | 表示yield指令，格式为yield  name                             |
| throw_stmt                    | name                                                         | 表示抛异常指令，格式为throw target                           |
| try_stmt                      | body<br>catch_body<br>else_body<br>final_body                | 表示try指令，格式为try body catch_body else_body final_body<br/>其中 body代表try内部的指令列表<br/>catch_body为catch关键字下面的指令列表，其内部可包含多个catch_stmt，<br/>else_body为else关键字下面的指令列表<br/>final为final关键字下面的指令列表 |
| catch_stmt                    | exception<br>body                                            | 表示catch指令，body为其内部指令列表                          |
| label_stmt                    | name                                                         | 表示label指令                                                |
| asm_stmt                      | target<br>data_type<br>attrs<br>data<br>extra<br>args        | target = attrs data(asm content), extra(input/out), args     |
| assert_stmt                   | condition                                                    | 表示assert指令，其格式为assert condition                     |
| del_stmt                      | name                                                         | 表示删除指令，例如python中 del target                        |
| unset_stmt                    | name                                                         | 表示重置指令，php                                            |
| pass_stmt                     |                                                              | 表示空指令                                                   |
| global_stmt                   | name                                                         | 表示全局应用指令，例如python中glabol target                  |
| nonlocal_stmt                 | name                                                         | 表示变量引用指令，例如python中nonlocal target                |
| type_cast_stmt                | target<br>data_type<br>source<br>error<br>cast_action        | 表示类型转换，格式为target = (data_type) source<br/>如果有错误，产生error |
| type_alias_stmt               | target<br>source                                             | 表示typedef指令，格式为typedef int a;<br/>target为a, source为int |
| with_stmt                     | attrs<br>with_init                                           | 表示with指令，后面接上下文管理器，其中attrs一般为async，with_init为对于上下文管理器的初始化操作，body为内部指令列表；<br/>对于一条with语句：async with aiofiles.open(filepath, 'r') as file:    <br/>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;content = await file.read()<br/>它的中间表示为：<br/>{'with_stmt': {'attrs': ['async'],       <br/>'with_init': [{'field_read': {'target': '%v0',                                              <br/>'receiver_object': 'aiofiles',                                              <br/>'field': 'open'}},                              <br/>{'call_stmt': {'target': '%v1',                                            <br/>'name': '%v0',                                             <br/>'args': ['filepath', ""'r'""]}},                              <br/>{'assign_stmt': {'target': 'file',                                               <br/>'operand': '%v1'}}],                <br/>'body': [{'field_read': {'target': '%v0',                                        <br/>'receiver_object': 'file',                                         <br/>'field': 'read'}},                         <br/>{'call_stmt': {'target': '%v1',                                        <br/>'name': '%v0',                                        <br/>'args': []}},                        <br/> {'await': {'target': '%v1'}},                         <br/>{'variable_decl': {'data_type': None,                                            <br/>'name': 'content'}},                         <br/>{'assign_stmt': {'target': 'content',                                         <br/> 'operand': None}}]}} |
| unsafe_block                  | body                                                         | 表示rust中的unsafe块<br/>其中body是一个指令列表              |
| block                         | body                                                         | 表示普通块<br/>其中body是一个指令列表                        |
| block_start                   | stmt_id<br>parent_stmt_id                                    | 内部指令，表示body的开始，不需要显式定义                     |
| block_end                     | stmt_id<br>parent_stmt_id                                    | 内部指令，表示body的结束，不需要显式定义                     |
| new_array                     | target<br>attrs<br>data_type                                 | 表示一个新数组的实例化格式为<br>target = attrs data_type[]   |
| new_object                    | target<br>attrs<br>data_type<br>args                         | 实例化一个类：target = attrs new datatype(args)              |
| new_record                    | target<br>attrs<br>data_type                                 | 表示一个新字典的实例化                                       |
| new_set                       | target<br>attrs<br>data_type                                 | 表示一个新集合的实例化                                       |
| new_struct                    | target<br>attrs<br>data_type                                 |                                                              |
| phi_stmt                      | target<br>phi_values<br>phi_labels                           | target = [phi_value, phi_label] <br/>【注】来自llvm，根据路径选择value |
| mem_read                      | target<br>address                                            | 用于从内存address中读取内容，其格式为target = *address       |
| mem_write                     | address<br>source                                            | 用于往内存address中写内容，其格式为*address = source         |
| array_write                   | array<br>index<br>source                                     | 用于写数组内容，格式为 array[index] = source                 |
| array_read                    | target<br>array<br>index                                     | 读取数组指定的元素例如a0 = result[0]                         |
| array_insert                  | array<br>source<br>index                                     | 用于向数组指定位置插入元素                                   |
| array_append                  | array<br>source                                              | 用于写数组内容，格式为 <array>.append(<source>)              |
| array_extend                  | array<br>source                                              | 用于写数组内容，格式为 <array>.extend(<source>)              |
| record_write                  | receiver_object<br>key<br>value                              | 用于写map中内容record[key] = value                           |
| record_extend                 | record<br>source                                             | 用于写map中内容<record>.update(<source>)                     |
| field_write                   | receiver_object<br>field<br>source                           | 用于写receiver_object中成员变量，格式为receiver_object.field = source |
| field_read                    | target<br>receiver_object<br>field                           | 用于读receiver_object中成员变量，格式为target = receiver_object.field |
| slice_wirte                   | array<br>source<br>start<br>end<br>step                      | 对应于python中的slice指令<br/>格式为 array[start: end: step] = source<br/>start: 切片开始的索引。<br/>stop: 切片结束的索引。<br/>step: 每次跳过的元素数。 |
| slice_read                    | target<br>array<br>start<br>end<br>step                      | 对应于python中的slice指令<br/>格式为 target = array[start: end: step]<br/>start: 切片开始的索引。<br/>stop: 切片结束的索引。<br/>step: 每次跳过的元素数。<br/><br/>以python为例：a = list[x:y:3]<br/>对应的中间表示为：<br/>{'slice_read': {'target': '%v1', 'array': 'list', 'start': 'x', 'end': 'y', 'step': '3'}} <br/>{'assign_stmt': {'target': 'a', 'operand': '%v1'}} |
| addr_of                       | target<br>source                                             | 用于取地址，其格式为target = &source                         |
| await_stmt                    | target                                                       |                                                              |
| field_addr                    | target<br>data_type<br>name                                  | 用于查询field在struct_decl中的地址编译量<br/><br/>例如：<br/>struct address {   <br/>&emsp;&emsp;char name[50];   <br/>&emsp;&emsp;char street[50];   <br/>&emsp;&emsp;int phone;<br/>};<br/>offsetof(struct address, name); <br/><br/>转换为target = data_type: address, name: name <br/><br/>【注】offsetof() |
| switch_type_stmt              | condition<br>body                                            | 表示switch指令，格式为switch(condition) <body><br/>其中condition为用于判断的变量 |
