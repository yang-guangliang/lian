This page describes our self-developed universal intermediate language. Compared to previous languages, GIR focuses more on concisely expressing logical relationships between variable symbols, while semantics like type inference, control flow, etc., are delegated to a subsequent "all-in-one" semantic analysis engine.

| **GIR**                       | **Attributes**                                               | **Description**                                              |
| ----------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| program                       | name<br>body                                                 |                                                              |
| namespace_decl                | name<br>body                                                 | namespace name {body}                                        |
| comment_stmt                  | data                                                         |                                                              |
| package_stmt                  | name                                                         | Represents a package declaration statement, formatted as `package name` |
| import_stmt                   | attrs<br>module_path<br>alias                                | Represents an import statement, formatted as `import module_path` or `import module_path as alias` <br><br/>Note：`module_path` is a directory or file path |
| from_import_stmt              | attrs<br>module_path<br>name<br>alias                        | `attrs` notes： <br/>- `unit` : `name` must be a filename, not a folder<br>- `init`：target file must be initialized during import |
| export_stmt                   | attrs<br>name<br>alias                                       | Represents an export command: `export <name> as <alias>`<br/>`attrs` identifies if it is `export default` (JS-only) |
| from_export_stmt              | attrs<br>module_path<br>name<br>alias                        |                                                              |
| require_stmt                  | target<br>name                                               | Represents a require statement: `target = require(name)`<br/>(PHP-only) |
| class_decl                    | attrs<br>name<br>supers<br>static_init<br>init<br>fields<br>methods<br>nested | Represents a class declaration:<br>\- `attrs`: properties like `public`, `static`, `private`<br/>\- `name`: class name<br/>\- `supers`: list of parent classes<br/>\- `fields`: member variables (each as `variable_decl`)<br/>\- `methods`: member functions (each as `method_decl`)<br/>- `nested`: list of other nested declaration<br>- `init`/`static_init`: initialization blocks, `init` for initialization of normal fields and `static_init` for initialization of the static fields<br> <br/><br/>Example:<br/>`public class Name extends A implements B { int i = 1; }`<br/>is represented as:<br/>`{"class_decl": {"attrs": ["public"], "name": "Name", "supers": ["A", "B"], "fields": [{"variable_decl": {"data_type": "int", "name": "i"}}], "init": [this.i = 1]}}` |
| record_decl                   | attrs<br>name<br>supers<br>type_parameters<br>static_init<br>init<br>fields<br>methods<br>nested | `type_parameter` is a list of all typed parameters, other is same as `class_decl` |
| interface_decl                | attrs<br>name<br>supers<br>type_parameters<br>static_init<br>init<br>fields<br>methods<br>nested | Same as `record_decl`                                        |
| enum_decl                     | attrs<br>name<br>supers<br>static_init<br>init<br>fields<br>methods<br>nested | Same as `class_decl`                                         |
| annotation_type_decl          | attrs<br>name<br>static_init<br>init<br>fields<br>methods<br>nested | Same as `class_decl`                                         |
| annotation_type_elements_decl | attrs<br>data_type<br>name<br>value                          | Same as `class_decl`                                         |
| struct_decl                   | attrs<br>name<br>fields                                      | Same as `class_decl`                                         |
| parameter_decl                | attrs<br>data_type<br>name<br>default_value                  | Represents parameter declarations.<br/>- `data_type`: the data type of parameter<br/>- `name`: name of the parameter<br/>- `default_value`: the default value <br/><br/>Example for `int f(int a, int b = 4)`: parameters are `[{"parameter_decl": {"data_type": "int", "name": "a"}}, {...}]` |
| variable_decl                 | attrs<br>data_type<br>name                                   | Represents local/field declarations.<br/>Example: `signed int i = 10` is split into:<br/>`[{"variable_decl": {"attrs": "signed", "data_type": "int", "name": "i"}}, {"assign_stmt": {"target": "i", "operand": 10}}]` |
| method_decl                   | attrs<br>data_type<br>name<br>parameters<br>body             | Represents function declarations.<br/>- `attrs`: properties like `public`, `static`, `private`<br/>- `data_type`: the data type of return value<br>\- `name`: name of the return value<br/>\- `parameters`: list of parameters, each of the list is `parameter_decl`<br/>\- `body`: list of the statements inside the method<br/>Example: `public int f(int a) {}` has `attrs: "public"`, `data_type: "int"`, `name: "f"`.<br/>Anonymous functions (e.g., Python `lambda x: x+1`) are converted to named temporary methods `def tmp_method(x): return x+1`. |
| assign_stmt                   | data_type<br>target<br>operand<br>operator<br>operand2       | Assignment statement:<br/>`target = operand [<operator> operand2]`<br/>Unary operation if `operand2` is missing (e.g., `a = -b`) |
| call_stmt                     | target<br>name<br>positional_args<br>packed_positional_args<br>named_args<br>packed_named_args<br>data_type<br>prototype | Function call logic, formatted as `target = name(args)`<br>- `target`: return value of the method, always a temporary variable<br/>\- `name`: name of the called method<br/>- `positional_args`: list of positional parameters<br/>\- `packed_positional_args`: Unwrapped positional parameters, and `positional_args` are mutually exclusive.<br/>\- `named_args`: list of keyword parameters<br/>\- `packed_named_args`: unwrapped keyword parameters, and `named_args` are mutually exclusive.<br/>- `data_type`: data type of the return value<br/>\- `prototype`: prototype of the called function, will be used in `llvm` and `dalvik`<br/><br/>Example for `e = o.f(a, b, c + d)`:<br>1. `%v1 = o.f`<br/>2. `%v2 = c + d`<br/>3. `%v3 = %v1(a, b, %v2)` // positional_args:[a, b, %v2]<br/>4. `e = %v3` <br/><br/>Example for `f(a,b,c, d=3)`: <br/>`call_stmt, name:f, positional_args:[a,b,c], named_args:{d:3} `<br/><br/>Example for `f(a, b, c, *l, d, a = b, c = d)`: <br/>1. `%v0 = [a, b, c]`<br/>2. `%v1 = %v0.update(l)`<br/>3. `%v2 = %v1.append(d)`<br/>`call_stmt, name:f, packed_positional_args:%v2, named_args:{a:b, c:d}`<br>Handles unpacking (e.g., `*l` → `packed_positional_args`). |
| echo_stmt                     | name                                                         | PHP `echo` statement.                                        |
| exit_stmt                     | name                                                         | PHP `exit` statement.                                        |
| return_stmt                   | name                                                         | Returns a variable: `return name`                            |
| if_stmt                       | condition<br>then_body<br>else_body                          | Example:<br/>`if (a + b > c) {}` →<br/>`%v1 = a + b`<br/>`%v2 = %v1 > c`<br/>`if (%v2) {...}` |
| dowhile_stmt                  | condition<br>body                                            | Similar to `if_stmt`                                         |
| while_stmt                    | condition<br>body<br>else_body                               | Similar to `if_stmt`                                         |
| for_stmt                      | init_body<br>condition<br>condition_prebody<br>update_body<br>body | Traditional `for` loop, formatted as `for (init_body; condition_prebody; condition; update_body) {}` <br>- `init_body`: list of statements, the initial block<br/>- `condition_prebody`: list of statements, used for pre-statements of judging condition<br/>- `condition`: a variable<br/>- `update_body`: list of statements, need to be execute every time in the cycle<br/><br/>Example for `for (int a = 1, b = 3; a +  b < 10; a ++, b++) {}`<br/>for_stmt: [  <br/>&emsp;&emsp;init_body: [       <br/>&emsp;&emsp;&emsp;&emsp;variable_decl int a       <br/>&emsp;&emsp;&emsp;&emsp;a = 1       <br/>&emsp;&emsp;&emsp;&emsp;variable_decl int b       <br/>&emsp;&emsp;&emsp;&emsp;b = 3   <br/>&emsp;&emsp;]  <br/>&emsp;&emsp;condition_prebody: [          <br/>&emsp;&emsp;&emsp;&emsp;%v1 = a + b          <br/>&emsp;&emsp;&emsp;&emsp;%v2 = %v1 < 10  <br/>&emsp;&emsp;]  <br/>&emsp;&emsp;condition: %v2  <br/>&emsp;&emsp;update_body: [        <br/>&emsp;&emsp;&emsp;&emsp;a = a + 1        <br/>&emsp;&emsp;&emsp;&emsp;b = b + 1  <br/>&emsp;&emsp;]  <br/>&emsp;&emsp;body : []<br/>] |
| forin_stmt                    | attrs<br>data_type<br>name<br>receiver<br>body               | Similar to `for_stmt`<br>- `attrs`: attributions of Iterative variables<br>- `data_type`: data type of Iterative variables<br/>- `name`: the Iterative variables<br/>- `receiver`: the target variable<br/>- `body`: list of statements<br/><br>Formatted as `for attrs data_type name in receiver {}`<br/>Iteration statement (e.g., `for x in list`).<br>`forin receiver:list name:x ` |
| for_value_stmt                | attrs<br>data_type<br>name<br>receiver<br>body               | Designed for JS `for of` and PHP `foreach`.                  |
| switch_stmt                   | condition<br>body                                            | `switch(condition) {body}`                                   |
| case_stmt                     | condition<br>body                                            | `case` block inside `switch`.                                |
| default_stmt                  | body                                                         | `default` block inside `switch`.                             |
| break_stmt                    | name                                                         | `break name`                                                 |
| continue_stmt                 | name                                                         | `continue name`                                              |
| goto_stmt                     | name                                                         | `goto name`                                                  |
| yield_stmt                    | name                                                         | `yield  name`                                                |
| throw_stmt                    | name                                                         | `throw target`                                               |
| try_stmt                      | body<br>catch_body<br>else_body<br>final_body                | `try {body} catch {catch_body} else {else_body} finally {final_body}` |
| catch_stmt                    | exception<br>body                                            | `catch` block                                                |
| label_stmt                    | name                                                         | Label declaration                                            |
| asm_stmt                      | target<br>data_type<br>attrs<br>data<br>extra<br>args        | Inline assembly: `target = attrs data(asm content)`          |
| assert_stmt                   | condition                                                    | `assert condition`                                           |
| del_stmt                      | receiver<br>name                                             | Python `del target`                                          |
| unset_stmt                    | receiver<br>name                                             | PHP `unset`                                                  |
| pass_stmt                     |                                                              | Empty statement (Python `pass`)                              |
| global_stmt                   | name                                                         | Python `global target`                                       |
| nonlocal_stmt                 | name                                                         | Python `nonlocal target`                                     |
| type_cast_stmt                | target<br>data_type<br>source<br>error<br>cast_action        | Type casting: `target = (data_type) source`<br>if there is an error, there will be an `error` |
| type_alias_stmt               | target<br>source                                             | Typedef: `typedef int a` → `target: a`, `source: int`        |
| with_stmt                     | attrs<br>with_init                                           | Context manager (e.g., Python `async with ... as file`).<br>- `attrs`: always be `async`<br>- `with_init`: the initialization of the context manager<br>- `body`: statements inside the `with_stmt`<br/><br>Example as `async with aiofiles.open(filepath, 'r') as file:`    <br/>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`content = await file.read()`<br/>the GIR is :<br>{'with_stmt': {'attrs': ['async'],       <br/>'with_init': [{'field_read': {'target': '%v0',                                              <br/>'receiver_object': 'aiofiles',                                              <br/>'field': 'open'}},                              <br/>{'call_stmt': {'target': '%v1',                                            <br/>'name': '%v0',                                             <br/>'args': ['filepath', ""'r'""]}},                              <br/>{'assign_stmt': {'target': 'file',                                               <br/>'operand': '%v1'}}],                <br/>'body': [{'field_read': {'target': '%v0',                                        <br/>'receiver_object': 'file',                                         <br/>'field': 'read'}},                         <br/>{'call_stmt': {'target': '%v1',                                        <br/>'name': '%v0',                                        <br/>'args': []}},                        <br/> {'await': {'target': '%v1'}},                         <br/>{'variable_decl': {'data_type': None,                                            <br/>'name': 'content'}},                         <br/>{'assign_stmt': {'target': 'content',                                         <br/> 'operand': None}}]}} |
| unsafe_block                  | body                                                         | Rust `unsafe` block                                          |
| block                         | body                                                         | Generic code block                                           |
| block_start                   | stmt_id<br>parent_stmt_id                                    | Internal marker for block start                              |
| block_end                     | stmt_id<br>parent_stmt_id                                    | Internal marker for block end                                |
| new_array                     | target<br>attrs<br>data_type                                 | Array instantiation: `target = attrs data_type[]`            |
| new_object                    | target<br>attrs<br>data_type<br>args                         | Class instantiation: `target = attrs new data_type(args)`    |
| new_record                    | target<br>attrs<br>data_type                                 | Dictionary instantiation                                     |
| new_set                       | target<br>attrs<br>data_type                                 | Set instantiation                                            |
| new_struct                    | target<br>attrs<br>data_type                                 | Struct instantiation                                         |
| phi_stmt                      | target<br>phi_values<br>phi_labels                           | LLVM-style phi node: `target = [phi_value, phi_label]`       |
| mem_read                      | target<br>address                                            | Read from memory: `target = *address`                        |
| mem_write                     | address<br>source                                            | Write to memory: `*address = source`                         |
| array_write                   | array<br>index<br>source                                     | Array write: `array[index] = source`                         |
| array_read                    | target<br>array<br>index                                     | Array read: `a0 = result[0]`                                 |
| array_insert                  | array<br>source<br>index                                     | Insert into array at `index`                                 |
| array_append                  | array<br>source                                              | Append to array: `<array>.append(<source>)`                  |
| array_extend                  | array<br>source                                              | Extend array: `<array>.extend(<source>)`                     |
| record_write                  | receiver_object<br>key<br>value                              | Map write: `record[key] = value`                             |
| record_extend                 | record<br>source                                             | Map extend: `<record>.update(<source>)`                      |
| field_write                   | receiver_object<br>field<br>source                           | Field write: `receiver_object.field = source`                |
| field_read                    | target<br>receiver_object<br>field                           | Field read: `target = receiver_object.field`                 |
| slice_wirte                   | array<br>source<br>start<br>end<br>step                      | Python slice write: `array[start:end:step] = source`<br>- `start`: The index at which the slice begins<br/>- `stop`: The index at which the slice stops<br/>- `step`: The number of skipped elements each time |
| slice_read                    | target<br>array<br>start<br>end<br>step                      | Python slice read: `target = array[start:end:step]`<br/><br>Example as `a = list[x:y:3]`<br/>{'slice_read': {'target': '%v1', 'array': 'list', 'start': 'x', 'end': 'y', 'step': '3'}} <br/>{'assign_stmt': {'target': 'a', 'operand': '%v1'}} |
| addr_of                       | target<br>source                                             | Address-of: `target = &source`                               |
| await_stmt                    | target                                                       | `await` statement                                            |
| field_addr                    | target<br>data_type<br>name                                  | Field offset calculation (e.g., `offsetof(struct address, name)`)<br/><br/>Example as <br>struct address {   <br/>&emsp;&emsp;char name[50];   <br/>&emsp;&emsp;char street[50];   <br/>&emsp;&emsp;int phone;<br/>};<br/>offsetof(struct address, name); <br/><br/>Convert to `target = data_type: address, name: name` |
| switch_type_stmt              | condition<br>body                                            | Type-based `switch` statement                                |
